# Python, Flask and Postgres

This is a bootstrap of a common dev stack. It has bits of code for writing a backend, unit tests, integration tests and code coverage.

Here are the assumptions.  

* Python/Flask used for one or more backend services
* Selenium integration tests

Eventually, I'll switch to have `docker-compose` is spin up the full stack. Right now it is mostly capturing some copy-pasta for python3, flask and selenium.

Extending the example to setup a postgres db and use ReactJS for a single page app frontend will come next.

## Testing Manually

You can still test and run each part of the app manually. This isn't preferred, but the instructions may be helpful for one-off tests or otherwise copying this work.


### Backend/Flask

The backend setup is based on using [Flask](http://flask.pocoo.org/docs/0.12/installation/) and can be run in a [Python3 venv](https://docs.python.org/3/library/venv.html#module-venv).

```
# create the venv to keep all installed libs local
python3 -m venv VENV

# enable venv
source VENV/bin/activate

# install all of the needed python libs
pip3 install -r requirements.txt

# launch the server
FLASK_APP=example/hello.py flask run
```

Open http://127.0.0.1:5000/ and you'll see the content sent by the Flask route bound to `/`.


### Unit Tests

Tests are run using Python3's standard unittest.

```
# coverage of just these tests
coverage run --source tests -m unittest tests/*.py

# show the test output
coverage report
```

Or run the tests individually or without coverage.

```
# run individual test file
python3 tests/flaskr_test.py

# run all using unittest
python3 -m unittest -v tests/*_test.py
```


## Integration Tests

Testing what a user sees when everything is together is arguably as or more important than the unit tests bundled with the backend. It is helpful to ensure that everything is correctly configured. It is also required for tests that rely on browser rendering of data provided by the backend.

Selenium and the [python bindings](http://selenium-python.readthedocs.io/installation.html) are used for these tests. It uses the [WebDriver](https://www.w3.org/TR/webdriver/) standard to connect and interact similar to a user on browsers such as Firefox, Chrome or Edge. 


```
# create the venv to keep all installed libs local
python3 -m venv VENV

# enable venv
source VENV/bin/activate

# install all of the needed python libs
pip3 install -r requirements.txt

# manually install the latest `geckodriver` for Firefox
# https://github.com/mozilla/geckodriver

# run all of the integration tests
python3 -m unittest tests/selenium_test.py
```

This above example assumes the Flask server is running and uses Firefox. You must manually download the latest [`geckodriver`]( https://github.com/mozilla/geckodriver/releases/tag/v0.19.0) and ensure it is in the environment path.


### Coverage Reports

There are two coverage reports of interest:

* Unit test coverage. Lines of code tested in isolated modules. If all is covered here, there is higher confidence it'll work.
* Integration test coverage. Lines of code used when testing user flows. If this works, things are wired together correctly and users should be able to successfuly use the tool.

Both of the above reports can be generated by `coverage`. The first is run whenever code changes in `flask`, and it doesn't rely on anything else. The integration tests are run after a full deploy of the project is done in the test environment. 

```
# run the server with coverage
flask/run_server.sh &

# run integration tests
integration/run_tests.sh

# now close the server
fg
ctrl+C

# generate the coverage report
pushd flask
coverage report
```
